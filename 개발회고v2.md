# 개발 회고 v2: Analysis Flow 리팩토링 및 안정성 개선

**버전**: 1.0.1  
**브랜치**: `feature/1.0.1`  
**작성일**: 2025년 11월 26일

---

## 1. 개요
이번 업데이트의 주 목적은 감정 분석 로직(`AnalysisViewModel`)의 구조를 개선하여 유지보수성을 높이고, 광고 노출 시점을 비즈니스 로직 사이로 유연하게 배치하는 것이었습니다. 이 과정에서 발생한 스레딩 이슈를 해결하며 앱의 안정성을 강화했습니다. 또한, 이미지 해시(ImageHash)를 활용한 중복 분석 방지 로직을 통합하여 불필요한 API 호출 비용을 절감했습니다.

## 2. 주요 변경 사항
- **로직 분리 (Refactoring)**: 거대한 하나의 함수(`analyzeImage`)를 단계별 책임이 명확한 3개의 함수(`performOCR`, `analyzeTone`, `saveRecord`)와 이를 조율하는 `analyze` 함수로 분리했습니다.
- **광고 시점 변경**: 분석 시작 전이 아닌, **OCR 성공 직후 & 감정 분석 API 호출 직전**으로 광고 노출 시점을 변경하여 UX를 개선했습니다.
- **스레드 안전성 확보**: `AdMobService`의 모든 UI 관련 로직이 메인 스레드에서 실행되도록 보장했습니다.
- **중복 분석 방지 (ImageHash)**: 분석 시작 전 이미지의 SHA-256 해시를 계산하여 DB에 저장된 기존 분석 결과가 있다면 API 호출 없이 즉시 결과를 반환합니다.

## 3. 트러블슈팅 (Troubleshooting)

### 🔥 이슈 1: AdMob Presentation Error
**현상**
- `AdMobService.showAd()` 호출 시 아래 에러와 함께 앱 크래시 발생.
  > `Terminating app due to uncaught exception 'NSGenericException', reason: 'Presentation Error: Presentation must be called on the main thread.'`

**원인 분석**
- `AnalysisViewModel`은 `@MainActor`로 선언되어 있었으나, `AdMobService`의 `showAd()`는 일반 `async` 함수였습니다.
- `await` 호출 시 실행 컨텍스트(Executor)가 변경될 수 있었고, 이로 인해 내부의 `present(from:)` 메서드가 백그라운드 스레드에서 호출되는 문제가 발생했습니다.

**해결 방법**
- `AdMobService` 클래스 전체에 **`@MainActor`** 어트리뷰트를 적용했습니다.
- 이를 통해 광고 로드(`loadAd`) 및 표시(`showAd`) 등 UI와 관련된 모든 작업이 컴파일러 수준에서 메인 스레드 실행을 보장받게 되었습니다.

```swift
// 수정 전
class AdMobService: NSObject { ... }

// 수정 후
@MainActor 
class AdMobService: NSObject { ... }
```

### 🔥 이슈 2: OCR 작업 시 UI 프리징 가능성
**현상**
- `AnalysisViewModel`이 `@MainActor`에서 동작하므로, 무거운 연산인 OCR 작업(`VisionOCRService.recognizeText`)이 메인 스레드를 점유할 위험이 있었습니다.

**해결 방법**
- OCR 서비스 내부에서 `Task.detached(priority: .userInitiated)`를 사용하여 명시적으로 백그라운드 스레드에서 작업을 수행하도록 변경했습니다.
- 결과값만 `await`를 통해 메인 액터로 안전하게 전달받는 구조로 개선했습니다.

## 4. ImageHash를 활용한 비용 절감 전략

### 구현 배경
- 동일한 이미지를 사용자가 실수로 중복 선택하거나 재분석을 시도할 경우, 불필요한 OpenAI API 호출이 발생하여 비용이 낭비되는 문제가 있었습니다.

### 구현 내용
1. **해시 생성**: `checkDuplicate(image:)` 메서드에서 이미지의 SHA-256 해시를 생성합니다.
2. **DB 조회**: `EmotionRecordRepository`를 통해 해당 해시값을 가진 기록이 있는지 확인합니다.
3. **결과 재사용**:
   - 중복이 발견되면(`existingRecord != nil`), 저장된 분석 결과(점수, 레이블, 키워드 등)를 즉시 로드합니다.
   - `ocrText`, `savedRecordId` 등 상태를 복원하고 단계를 `.completed`로 설정하여 API 호출을 건너뜁니다.
4. **신규 저장**: 새로운 이미지 분석 성공 시, `saveRecord` 단계에서 이미지 해시를 함께 저장하여 다음 분석 시 활용합니다.

```swift
// AnalysisViewModel.swift
private func checkDuplicate(image: UIImage) -> Bool {
  let imageHash = image.sha256Hash()
  // ... DB 조회 로직 ...
  if let existingRecord = try repository.findByImageHash(imageHash) {
    // 저장된 결과 로드 및 반환
    return true
  }
  return false
}
```

## 5. 배운 점 (Learnings)

1. **Swift Concurrency의 스레드 모델**
   - `async` 함수라고 해서 자동으로 백그라운드 스레드로 넘어가는 것이 아니며, 호출자(Caller)의 컨텍스트를 상속받을 수 있음을 확인했습니다.
   - UI 업데이트가 포함된 서비스 클래스는 반드시 `@MainActor`를 명시해야 안전합니다.

2. **단일 책임 원칙 (SRP)의 중요성**
   - `analyzeImage` 함수를 분리하니 코드의 가독성이 좋아진 것은 물론, "광고를 어디에 넣을지"와 같은 흐름 제어가 훨씬 직관적으로 변했습니다.

## 6. 향후 개선 계획
- **광고 로드 실패에 대한 Fallback**: 광고 로드 실패 시 즉시 분석으로 넘어가는 로직은 구현되어 있으나, 네트워크 상태에 따른 재시도 로직 추가 고려.
- **사용자 경험(UX)**: OCR 분석 시간이 길어질 경우를 대비해 로딩 인디케이터에 "텍스트 인식 중..."과 같은 구체적인 상태 메시지 표시.
